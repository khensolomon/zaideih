{"version":3,"sources":["webpack://zaideih/./assets/script/sw.js"],"names":["CACHE_NAME","self","addEventListener","event","waitUntil","cache","caches","open","add","Request","skipWaiting","registration","navigationPreload","enable","clients","claim","request","mode","respondWith","preloadResponse","fetch","error","console","log","match"],"mappings":"oBAAA,WACE,MACMA,EAAa,UAInBC,KAAKC,iBAAiB,WAAYC,IAChCA,EAAMC,UACJ,WACE,MAAMC,QAAcC,OAAOC,KAAKP,SAI1BK,EAAMG,IAAI,IAAIC,QATN,IAS2B,CAAEJ,MAAO,aALpD,IASFJ,KAAKS,iBAGPT,KAAKC,iBAAiB,YAAaC,IACjCA,EAAMC,UACJ,WAGM,sBAAuBH,KAAKU,oBACxBV,KAAKU,aAAaC,kBAAkBC,UAJ9C,IAUFZ,KAAKa,QAAQC,WAGfd,KAAKC,iBAAiB,SAAUC,IAGH,aAAvBA,EAAMa,QAAQC,MAChBd,EAAMe,YACJ,WACE,IAEE,MAAMC,QAAwBhB,EAAMgB,gBACpC,OAAIA,SAK0BC,MAAMjB,EAAMa,SAE1C,MAAOK,GAKPC,QAAQC,IAAI,gDAAiDF,GAE7D,MAAMhB,QAAcC,OAAOC,KAAKP,GAEhC,aAD6BK,EAAMmB,MAvDzB,OAoCd,OAxCR,I","file":"sw.js","sourcesContent":["(function() {\r\n  const OFFLINE_VERSION = 1;\r\n  const CACHE_NAME = \"offline\";\r\n  // Customize this with a different URL if needed.\r\n  const OFFLINE_URL = \"/\";\r\n\r\n  self.addEventListener(\"install\", (event) => {\r\n    event.waitUntil(\r\n      (async () => {\r\n        const cache = await caches.open(CACHE_NAME);\r\n        // Setting {cache: 'reload'} in the new request will ensure that the\r\n        // response isn't fulfilled from the HTTP cache; i.e., it will be from\r\n        // the network.\r\n        await cache.add(new Request(OFFLINE_URL, { cache: \"reload\" }));\r\n      })()\r\n    );\r\n    // Force the waiting service worker to become the active service worker.\r\n    self.skipWaiting();\r\n  });\r\n\r\n  self.addEventListener(\"activate\", (event) => {\r\n    event.waitUntil(\r\n      (async () => {\r\n        // Enable navigation preload if it's supported.\r\n        // See https://developers.google.com/web/updates/2017/02/navigation-preload\r\n        if (\"navigationPreload\" in self.registration) {\r\n          await self.registration.navigationPreload.enable();\r\n        }\r\n      })()\r\n    );\r\n\r\n    // Tell the active service worker to take control of the page immediately.\r\n    self.clients.claim();\r\n  });\r\n\r\n  self.addEventListener(\"fetch\", (event) => {\r\n    // We only want to call event.respondWith() if this is a navigation request\r\n    // for an HTML page.\r\n    if (event.request.mode === \"navigate\") {\r\n      event.respondWith(\r\n        (async () => {\r\n          try {\r\n            // First, try to use the navigation preload response if it's supported.\r\n            const preloadResponse = await event.preloadResponse;\r\n            if (preloadResponse) {\r\n              return preloadResponse;\r\n            }\r\n\r\n            // Always try the network first.\r\n            const networkResponse = await fetch(event.request);\r\n            return networkResponse;\r\n          } catch (error) {\r\n            // catch is only triggered if an exception is thrown, which is likely\r\n            // due to a network error.\r\n            // If fetch() returns a valid HTTP response with a response code in\r\n            // the 4xx or 5xx range, the catch() will NOT be called.\r\n            console.log(\"Fetch failed; returning offline page instead.\", error);\r\n\r\n            const cache = await caches.open(CACHE_NAME);\r\n            const cachedResponse = await cache.match(OFFLINE_URL);\r\n            return cachedResponse;\r\n          }\r\n        })()\r\n      );\r\n    }\r\n\r\n    // If our if() condition is false, then this fetch handler won't intercept the\r\n    // request. If there are any other fetch handlers registered, they will get a\r\n    // chance to call event.respondWith(). If no fetch handlers call\r\n    // event.respondWith(), the request will be handled by the browser as if there\r\n    // were no service worker involvement.\r\n  });\r\n})();\r\n"],"sourceRoot":""}